<!DOCTYPE html>
<html lang="en" dir="ltr">

<head>
  <meta charset="utf-8">
  <title></title>
  <script type="module" src="./main.js">

  </script>
</head>

<body style="position:fixed;width:100vw;height:100vh;margin:0">


</body>
<script type="module">
  import * as THREE from '../ThreeJsLib/build/three.module.js';
  import {
    OrbitControls
  } from '../ThreeJsLib/examples/jsm/controls/OrbitControls.js'



  let RENDERER, CAMERA, SCENE,TARGET_MESH;
  const RADIUS = 1;
  const objectLoader = new THREE.ObjectLoader();
  let CONTROLS;
  const MOUSE = {
    x:0,
    y:0,
  };
  document.body.addEventListener('mousemove',function(e){
    MOUSE.x = e.clientX;
    MOUSE.y = e.clientY;
  });




  function initializeScene() {
    RENDERER = new THREE.WebGLRenderer();
    document.querySelector('body').appendChild(RENDERER.domElement);
    RENDERER.domElement.style.position = 'fixed';
    CAMERA = new THREE.PerspectiveCamera(45, 2, 1, 1000);
    CAMERA.position.set(4, 10, 4);
    CAMERA.lookAt(0, 0, 0);
    SCENE = new THREE.Scene();
    SCENE.fog = new THREE.FogExp2(0xDAFBFB,0.03);
    RENDERER.toneMapping = THREE.ACESFilmicToneMapping;
    RENDERER.toneMappingExposure = 2;

    SCENE.background = new THREE.Color( 0x303030 );
    RENDERER.shadowMap.enabled = true;
    // CONTROLS = new OrbitControls(CAMERA, RENDERER.domElement);
    RENDERER.shadowMapSoft = true;
    RENDERER.shadowMap.type = THREE.PCFSoftShadowMap;

    // const geo = new THREE.BoxBufferGeometry(0.5,1,0.5);
    // const mat = new THREE.MeshBasicMaterial({color:0xFF0000});
    //  TARGET_MESH = new THREE.Mesh(geo,mat);
    // SCENE.add( TARGET_MESH );

    window.addEventListener("resize", setSizes);
    setSizes();
    RENDER();

  };


  const cameraInterface = {
    cameraMoves:{
      top:0,
      left:0,
    },
    cameraPosition:{
      x:6,
      y:0,
      z:6,
    },
    cameraTarget:{
      x:0,
      y:0,
      z:0,
      distance:5.65685424949,
    },
    // sin:7.05132817881,

    cameraSpeed:0.5,

    check:function(){
      const windowWidth = document.body.clientWidth;
      const windowHeight = document.body.clientHeight;
      if(MOUSE.y < windowHeight*0.10 && MOUSE.y > 0){
        cameraInterface.cameraMoves.top=-1;
      }
      if(MOUSE.y > windowHeight - windowHeight*0.10 && MOUSE.y < windowHeight){
        cameraInterface.cameraMoves.top=1;
      }
      if(MOUSE.x < windowWidth*0.06 && MOUSE.x > 0){
        cameraInterface.cameraMoves.left=-1;
      }
      if(MOUSE.x > windowWidth - windowWidth*0.06 && MOUSE.y < windowWidth){
        cameraInterface.cameraMoves.left=1;
      }
      if(MOUSE.y > windowHeight*0.10 && MOUSE.y < windowHeight - windowHeight*0.10){
        cameraInterface.cameraMoves.top=0;
      }
      if(MOUSE.x > windowWidth*0.06 && MOUSE.x < windowWidth - windowWidth*0.06){
        cameraInterface.cameraMoves.left=0;
      }

    },

    update:function(){
      cameraInterface.check();

      const upShift = cameraInterface.cameraSpeed * cameraInterface.cameraMoves.top;
      const sideShift = cameraInterface.cameraSpeed * cameraInterface.cameraMoves.left;

      let topShiftX = upShift/2;
      let topShiftY = upShift/2;
      let leftShiftX = sideShift/2;
      let leftShiftY = -sideShift/2;


      cameraInterface.cameraPosition.x +=  topShiftX+ leftShiftX;
      cameraInterface.cameraPosition.z +=  topShiftY+leftShiftY;


      cameraInterface.cameraTarget.x = cameraInterface.cameraPosition.x - 4;
      cameraInterface.cameraTarget.z = cameraInterface.cameraPosition.z - 4;

      CAMERA.position.x = cameraInterface.cameraPosition.x;
      CAMERA.position.z = cameraInterface.cameraPosition.z;

      // TARGET_MESH.position.x = cameraInterface.cameraTarget.x;
      // TARGET_MESH.position.z= cameraInterface.cameraTarget.z;

    },
  }
  initializeScene();


  function setSizes() {

    const windowWidth = document.body.clientWidth;
    const windowHeight = document.body.clientHeight;

    const pixelRatio = window.devicePixelRatio;

    RENDERER.setSize(windowWidth * pixelRatio, windowHeight * pixelRatio, true);


    RENDERER.domElement.style.width = windowWidth + 'px';
    RENDERER.domElement.style.height = windowHeight + 'px';
    CAMERA.aspect = windowWidth / windowHeight;
    CAMERA.updateProjectionMatrix();
  };

  function RENDER() {
    // CONTROLS.update();
    RENDERER.render(SCENE, CAMERA);
    // requestAnimationFrame(RENDER)
    cameraInterface.update();
    setTimeout(RENDER,1000/30)
  };


//





  {
    {
      const light = new THREE.HemisphereLight(0x11252C, 0x404040, 1);
      SCENE.add(light);
    }

    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.castShadow = true;
    light.position.set(0, 2, 10);
    light.target.position.set(0, 0, 0);
    // light.shadow.mapSize.width = 256;
    // light.shadow.mapSize.height = 256;
    light.shadow.width = 128;
    light.shadow.height = 128;
    light.shadow.camera.zoom = 0.5;
    light.shadow.camera.near = 0;
    light.shadow.camera.far = 30;


    const cameraHelper = new THREE.CameraHelper(light.shadow.camera);
        // SCENE.add(cameraHelper);
    SCENE.add(light);
    SCENE.add(light.target);

    const helper = new THREE.DirectionalLightHelper(light);
    // SCENE.add(helper);
  }








  const MODELS = {
    map: {
      sand: {
        title: 'sand',
        link: "../models/map/sand_01.json",
        obj: {},
      },
      meadow: {
        title: 'meadow',
        link: "../models/map/meadow_01.json",
        obj: {},
      },
      water: {
        title: 'water',
        link: "../models/map/water_01.json",
        obj: {},
      },
      forest: {
        title: 'forest',
        link: "../models/map/forest_01.json",
        obj: {},
      },

    },

    index: -1,
    loader: function(modelTitle) {
      objectLoader.load(MODELS.map[modelTitle].link,
        function(obj) {
          // Add the loaded object to the scene
          obj.castShadow = true;
          obj.receiveShadow = true;
          MODELS.map[modelTitle].obj = obj;
          MODELS.loadNext();
        },
      );
    },

    loadNext: function() {
      const arr = Object.keys(MODELS.map);
      MODELS.index++;
      if (MODELS.index < arr.length) {
        MODELS.loader(arr[MODELS.index]);
      } else {
        generateMap();
      };
    },
  };

  MODELS.loadNext();


  const PERLIN_YWRAPB = 4;
  const PERLIN_YWRAP = 1 << PERLIN_YWRAPB;
  const PERLIN_ZWRAPB = 8;
  const PERLIN_ZWRAP = 1 << PERLIN_ZWRAPB;
  const PERLIN_SIZE = 4095;

  let perlin_octaves = 4; // default to medium smooth
  let perlin_amp_falloff = 0.5; // 50% reduction/octave

  const scaled_cosine = i => 0.5 * (1.0 - Math.cos(i * Math.PI));

  let perlin; // will be initialized lazily by noise() or noiseSeed()


  const noise = function(x, y = 0, z = 0) {
    if (perlin == null) {
      perlin = new Array(PERLIN_SIZE + 1);
      for (let i = 0; i < PERLIN_SIZE + 1; i++) {
        perlin[i] = Math.random();
      }
    }

    if (x < 0) {
      x = -x;
    }
    if (y < 0) {
      y = -y;
    }
    if (z < 0) {
      z = -z;
    }

    let xi = Math.floor(x),
      yi = Math.floor(y),
      zi = Math.floor(z);
    let xf = x - xi;
    let yf = y - yi;
    let zf = z - zi;
    let rxf, ryf;

    let r = 0;
    let ampl = 0.5;

    let n1, n2, n3;

    for (let o = 0; o < perlin_octaves; o++) {
      let of = xi + (yi << PERLIN_YWRAPB) + (zi << PERLIN_ZWRAPB);

      rxf = scaled_cosine(xf);
      ryf = scaled_cosine(yf);

      n1 = perlin[ of & PERLIN_SIZE];
      n1 += rxf * (perlin[( of +1) & PERLIN_SIZE] - n1);
      n2 = perlin[( of +PERLIN_YWRAP) & PERLIN_SIZE];
      n2 += rxf * (perlin[( of +PERLIN_YWRAP + 1) & PERLIN_SIZE] - n2);
      n1 += ryf * (n2 - n1);

      of += PERLIN_ZWRAP;
      n2 = perlin[ of & PERLIN_SIZE];
      n2 += rxf * (perlin[( of +1) & PERLIN_SIZE] - n2);
      n3 = perlin[( of +PERLIN_YWRAP) & PERLIN_SIZE];
      n3 += rxf * (perlin[( of +PERLIN_YWRAP + 1) & PERLIN_SIZE] - n3);
      n2 += ryf * (n3 - n2);

      n1 += scaled_cosine(zf) * (n2 - n1);

      r += n1 * ampl;
      ampl *= perlin_amp_falloff;
      xi <<= 1;
      xf *= 2;
      yi <<= 1;
      yf *= 2;
      zi <<= 1;
      zf *= 2;

      if (xf >= 1.0) {
        xi++;
        xf--;
      }
      if (yf >= 1.0) {
        yi++;
        yf--;
      }
      if (zf >= 1.0) {
        zi++;
        zf--;
      }
    }
    return r;
  };




  function getMapTypeByRandom(random) {
    if(random <= 0.3){
      return 'water'
    }
    else if(random > 0.3 && random <0.4){
      return 'sand'
    }
    else if(random >= 0.4 && random <0.6){
        return 'meadow'
    }else{
      return 'forest'
    }

    // const arr =  Object.keys(MODELS.map)
    // const options = arr.length-1;
    // const type = Math.round(Math.round(random*10)/10 * options);
    //
    // return arr[type];
  }



  function generateMap() {
    function randomInteger(min, max) {
      // получить случайное число от (min-0.5) до (max+0.5)
      let rand = min - 0.5 + Math.random() * (max - min + 1);
      return Math.round(rand);
    }

    const xGrid = 10;
    const zGrid = 10;






    for (let z = 0; z < zGrid; z++) {
      for (let x = 0; x < xGrid; x++) {
        const biomeSize = 10;

        const modelTypesArr = Object.keys(MODELS.map);
        const modelType = modelTypesArr[0];
        const mesh = MODELS.map[getMapTypeByRandom(noise(z / biomeSize, x / biomeSize))].obj.clone();
        SCENE.add(mesh);
        if (z % 2) {
          mesh.position.x = 0.86602540378 + 0.86602540378 * 2 * (x-xGrid/2);
        } else {
          mesh.position.x = 0.86602540378 * 2 * (x-xGrid/2);
        }
        mesh.position.z = (z-zGrid/2) * 1.5;


        mesh.rotation.y = randomInteger(0, 5) * 60 * Math.PI / 180;

      };
    };


  };
</script>

</html>
